\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc} % Umlaute
\usepackage[T1]{fontenc} % Pipes
\usepackage[ngerman]{babel} % Deutsche Captions
\usepackage{listings} % source code listings
\usepackage{multicol} % Aufzählungen in mehreren Spalten
\usepackage[margin=1.5in]{geometry}

% Optionen für Listings
% \lstset{
% 	breaklines=true,
% 	keepspaces=false
% }

\title{Phoenix \\ \large Konstruktion eines Compilers}
\author{Alexander Miller, Daniel Brand \\ \\
		VP Grundlagen Compilerbau \\
		Fachbereich für Computerwissenschaften \\
		Universität Salzburg}
\date{\today}

\setcounter{tocdepth}{2}

\begin{document}
	\maketitle
	%\newpage
	\tableofcontents
	%\newpage

	\section{Einleitung}
	Diese Dokumentation beschreibt die Features unseres Compilers Phoenix.
	Wir entschieden uns für C als Sprache, da die geforderten sprachlichen Features damit unmittelbar umgesetzt werden können.

	\subsection{Team}
	Phoenix wurde geschrieben von:
	\begin{itemize}
		\item Daniel Brand (1023077)
		\item Alexander Miller (1120667)
	\end{itemize}

	\section{Features}
	\begin{multicols}{2}
	\begin{itemize}
		\item Basic Types
		\item Arrays
		\item Records
		\item Boolean Expressions
		\item Arithmetic Expressions
		\item Strings
		\item File I/O
		\item While (auch verschachtelt)
		\item If-Else (auch verschachtelt)
		\item Lazy Evaluation
		\item Call-by-value
		\item Call-by-reference
		\item Scoping von Variablen (Global und lokal)
		\item Type-checking
	\end{itemize}
	\end{multicols}

	Nicht implementiert:
	\begin{itemize}
		\item Self-Compilation
		\item Seperate Compilation
	\end{itemize}

	\section{Aufbau}
	Phoenix ist in mehrere Teile aufgeteilt.
	\begin{itemize}
		\item Scanner (in scanner.c)
		\item Parser (in parser.c)
		\item Code Generation (ebenfalls in parser.c)
		\item Target Machine (in margit.c)
	\end{itemize}


	\section{Scanner}
	Der Scanner liest ein Textfile in ASCII-Kodierung ein und fügt Zeichen zu syntaktischen Einheiten (Tokens) zusammen.
	Diese Tokens sind in ihrer Bedeutung eindeutig definiert (Anhang).

	Der Scanner in Phoenix liest solange Zeichen von der Eingabedatei ein, bis er eine Wortgrenze erkennt.
	Danach versucht er, das bis zu diesem Zeitpunkt eingelesene Wort zu kategorisieren und dies als Token an den Parser weiter zu geben.

	\section{Parser}
	Der Parser arbeitet nach dem LL(1)-Prinzip. Er liest von Links nach Rechts, evaluert von Links und hat einen Lookahead von einem Token.

	\subsection{Typen}

	Phoenix unterstützt die Deklaration von Variablen vom Typ Integer und Character.
	Implizit können auch Booleans deklariert werden.
	Da aber der boolesche Datentyp in C nicht explizit vorhanden ist, kann keine Variable vom Typ bool angelegt werden.
	Eine Zuweisung eines booleschen Ausdrucks zu einer Integervariable ist jedoch möglich (wird aber vom Parser als Typkonflikt erkannt).

	\subsubsection{Arrays}

	\subsubsection{Records}

	\subsection{Schleifen}

	Phoenix-C erlaubt nur while-Schleifen. for-Schleifen können aber damit ebenfalls ausgedrückt werden.

	\subsection{Type Checking}
	Erklärung von Type Checking

	\subsection{Boolean Expressions}

	\subsection{Lazy Evaluation}

	\subsection{Arithmetic Expressions}

	\section{Code Generation}
	Recursive descent.

	\section{Target Machine}
	Die Target Machine ist eine DLX-Maschine.
	Somit besitzt sie 32 Register mit jeweils 32bit.
	Zusätzlich zu den DLX-Befehlen haben wir neue Instruktionen für Input/Output eingeführt.

	\subsection{Binärformat}
	Das erwartete Binärformat ist in folgende Segmente aufgeteilt.
	\begin{itemize}
		\item Code
		\item Strings
		\item Globale Variablen
	\end{itemize}

	Zur Laufzeit werden von der Target Machine Heap und Stack zur Verfügung gestellt.

	\subsection{Ausführung}
	Die Target Machine lädt das Binärfile in den virtuellen RAM.
	Der GP wird an die erste freie Stelle nach dem gelesen File gesetzt.
	Der PC wird auf 1 gesetzt.

	\subsection{System IO}
	Wir haben neue Instruktionen für Input und Output eingeführt.
	Diese sind analog zu den benutzten POSIX-Syscalls.
	\begin{itemize}
		\item fopen
		\item fclose
		\item fgetc
		\item fputc
		\item printf
	\end{itemize}

	\newpage
	\section{Anhang 1: EBNF}
	\begin{lstlisting}
start = {include_def} {top_declaration}.

include_def = "#include" (string_literal ||
	("<" {identifier || "."} ">") ).

top_declaration = type_declaration ";" ||
				variable_declaration ";" ||
				function_declaration.

type_declaration = struct_declaration || typedef_declaration.

variable_declaration = ["static"] type ["*"] identifier.

function_declaration = type identifier formalParameters
	(
		";" ||
		"{" [variableDeclarationSequence] {instruction} "}"
	).

struct_declaration = "struct" identifier
	"{" {variable_declaration ";"} "}".

typedef_declaration =

type = "int" || "char" || "void" || identifier || ("struct" identifier).

identifier = letter {letter || digit}.

formalParameters = "(" formalParameter { "," formalParameter } ")".

formalParameter = type identifier.

variableDeclarationSequence = { variable_declaration ";" }.

instruction = if_else ||
	fclose_func ";" ||
	while_loop ||
	return_statement ";" ||
	printf_func ";" ||
	fputc_func ";" ||
	identifier ( actualParameters || "=" expression) ";".

if_else = "if" "(" expression ")" "{" { instruction } "}" [ "else" "{" { instruction } "}" ].

fclose_func = "fclose" "(" expression ")".

while_loop = "while" "(" expression ")" "{" { instruction } ")".

return_statement = "return" [expression].

printf_func = "printf" "(" expression ")".

fputc_func = "fputc" "(" expression "," expression ")".

actualParameters = "(" [expression { "," expression } ] ")".

expression = simple_expression [ ("==" || "<=" || "<" || "!=" || ">" || ">=") expression ].

simple_expression = ("-" simple_expression) ||
	term [ ("+" || "-" || "||") term].

term = factor [ ("*" || "/" || "&") factor].

factor = ("!" factor) ||
	"(" expression ")" ||
	integer ||
	string_literal ||
	identifier ||
	sizeof_func ||
	malloc_func ||
	fopen_func ||
	fgetc_func ||
	fputc_func.

sizeof_func = "sizeof" "(" type ")".

malloc_func = "malloc" "(" expression ")".

fopen_func = "fopen" "(" expression ["," expression] ")".

fgetc_func = "fgetc" "(" expression ")".

fputc_func = "fputc" "(" expression "," expression ")".

string_literal = """ string """.

string = letter { letter || digit || " " }.

integer = digit { digit }.

letter = A-Za-z.

digit = 0-9.
	\end{lstlisting}

	\newpage
	\section{Anhang 2: Unterstütze Instruktionen}
	\begin{lstlisting}
	TARGET_NOP = 0;

	// F1 (1-23)
	ADDI
	SUBI
	MULI
	DIVI
	MODI
	CMPI
	LW
	SW
	POP
	PSH
	BEQ
	BGE
	BGT
	BLE
	BLT
	BNE
	BR
	BSR
	MALLOC
	RET
	FOPEN
	FGETC
	FPUTC

	// F2 (24-43)
	SUB
	MUL
	DIV
	MOD
	CMP
	RET
	AND
	OR
	PRINTF
	PRINTFI
	ADD

	// F3 (43-63)
	JSR
	J
	TRAP
	FCLOSE
	\end{lstlisting}
\end{document}