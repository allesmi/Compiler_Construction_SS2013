\documentclass{article}
\usepackage[utf8]{inputenc} % Umlaute
\usepackage[T1]{fontenc} % Pipes
\usepackage[ngerman]{babel} % Deutsche Captions

\title{Phoenix}
\author{Alexander Miller, Daniel Brand \\ \\
		Compiler Construction \\
		Department of Computer Sciences \\
		University of Salzburg}
\date{\today}

\setcounter{tocdepth}{2}

\begin{document}
	\maketitle
	%\newpage
	\tableofcontents
	%\newpage

	\section{Einleitung}
	\subsection{Beschreibung}
	Phoenix ist ein Compiler für eine Teilmenge von C, geschrieben in C.
	Ausgabesprache ist ein Binärformat für einen DLX Interpreter.
	Phoenix unterstützt grundlegende Sprachkonzepte: Type Checking, Lazy Evaluation, Arrays und Records.

	\subsection{Team}
	Phoenix wurde geschrieben von:
	\begin{itemize}
		\item Daniel Brand (1023077)
		\item Alexander Miller (1120667)
	\end{itemize}

	\section{Aufbau}
	Phoenix ist in mehrere Teile aufgeteilt.
	\begin{itemize}
		\item Scanner (in scanner.c)
		\item Parser (in parser.c)
		\item Code Generation (ebenfalls in parser.c)
		\item Target Machine (in margit.c)
	\end{itemize}


	\section{Scanner}
	Der Scanner liest ein Textfile in ASCII-Kodierung ein und fügt Zeichen zu syntaktischen Einheiten (Tokens) zusammen.
	Diese Tokens sind in ihrer Bedeutung eindeutig definiert (Anhang).

	Der Scanner in Phoenix liest solange Zeichen von der Eingabedatei ein, bis er eine Wortgrenze erkennt.
	Danach versucht er, das bis zu diesem Zeitpunkt eingelesene Wort zu kategorisieren und dies als Token an den Parser weiter zu geben.

	\section{Parser}
	Der Parser arbeitet nach dem LL(1)-Prinzip. Er liest von Links nach Rechts, evaluert von Links und hat einen Lookahead von einem Token.

	\subsection{Typen}

	Phoenix unterstützt die Deklaration von Variablen vom Typ Integer und Character.
	Implizit können auch Booleans deklariert werden.
	Da aber der boolesche Datentyp in C nicht explizit vorhanden ist, kann keine Variable vom Typ bool angelegt werden.
	Eine Zuweisung eines booleschen Ausdrucks zu einer Integervariable ist jedoch möglich (wird aber vom Parser als Typkonflift erkannt).

	\subsubsection{Arrays}

	\subsubsection{Records}

	\subsection{Schleifen}

	Unser C erlaubt nur while-Schleifen.

	\subsection{Type Checking}
	Erklärung von Type Checking

	\subsection{Boolean Expressions}

	\subsection{Lazy Evaluation}

	\subsection{Arithmetic Expressions}

	\section{Code Generation}
	Recursive descent.

	\section{Target Machine}
	Die Target Machine ist eine DLX-Maschine.
	Somit besitzt sie 32 Register mit jeweils 32bit.
	Zusätzlich zu den DLX-Befehlen haben wir neue Instruktionen für Input/Output eingeführt.

	\subsection{Binärformat}
	Das erwartete Binärformat ist in folgende Segmente aufgeteilt.
	\begin{itemize}
		\item Code
		\item Strings
		\item Globale Variablen
	\end{itemize}

	Zur Laufzeit werden von der Target Machine Heap und Stack zur Verfügung gestellt.

	\subsection{Ausführung}
	Die Target Machine lädt das Binärfile in den virtuellen RAM.
	Der GP wird an die erste freie Stelle nach dem gelesen File gesetzt.
	Der PC wird auf 1 gesetzt.

	\subsection{System IO}
	Wir haben neue Instruktionen für Input und Output eingeführt.
	Diese sind analog zu den benutzten POSIX-Syscalls.
	\begin{itemize}
		\item fopen
		\item fclose
		\item fgetc
		\item fputc
		\item printf
	\end{itemize}

	\newpage
	\section{Anhang 1: EBNF}
	start ::= top\_declaration || function\_declaration.

	\newpage
	\section{Anhang 2: Unterstütze Instruktionen}
	J
	BSR
	ADDI
	etc.
\end{document}